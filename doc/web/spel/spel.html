<html>
<head><title>Simplest Possible Expression Language (SPEL) for
JSPSTL</title></head>

<body>
<h1>Simplest Possible Expression Language (SPEL) for JSPSTL</h1>
<h4>Nathan Abramson (arista@atg.com)</h4>

<h2>Overview</h2>

<p>The SPEL is designed to be the simplest possible JSPSTL expression
language that is still useful.  The only required features of the SPEL
are:

<ul>

<li>notion of scope (page, request, session, app)
<li>nested attributes
<li>relational operators

</ul>

<p>The idea is to design a language that will eventually grow, keeping
in mind that future versions of the language should be backwards
compatible with this version of the SPEL.

<h2>Syntax</h2>

<p>The syntax is extremely simple.  Attributes are accessed by name,
with an optional scope ("page:", "request:", "session:", "app:").
Properties of attributes are accessed using the "." operator, and may
be nested arbitrarily.  Attribute and property names must be java
identifiers, unless they are quoted.  Relational comparisons are
allowed using the relational operators (==, !=, &lt;, &gt;, &lt;=,
&gt;=).  Comparisons may be made against other values, or against
boolean, String, integer, or floating point literals.

<p>The following are the constructs supported by the SPEL:

<table>

<tr>
<td><b>Expression</b></td>
<td>::=</td>
<td><b>Value</b></td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>| <b>RelationalExpression</b></td>
</tr>

<tr>
<td><b>RelationalExpression</b></td>
<td>::=</td>
<td><b>Value RelOp Value</b></td>
</tr>

<tr>
<td><b>RelOp</b></td>
<td>::=</td>
<td><b>'=='</b></td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>| '!='</b></td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>| '&lt;'</b></td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>| '&gt;'</b></td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>| '&lt;='</b></td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>| '&gt;='</b></td>
</tr>

<tr>
<td><b>Value</b></td>
<td>::=</td>
<td><b>PropertyValue</b></td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>| <b>Literal</b></td>
</tr>

<tr>
<td><b>PropertyValue</b></td>
<td>::=</td>
<td><b>NamedValue</b></td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>| <b>PropertyValue</b> '.' <b>Identifier</b></td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>| <b>PropertyValue</b> '.' <b>StringLiteral</b></td>
</tr>

<tr>
<td><b>NamedValue</b></td>
<td>::=</td>
<td><b>ScopedIdentifier</b></td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>| <b>Identifier</b></td>
</tr>

<tr>
<td><b>ScopedIdentifier</b></td>
<td>::=</td>
<td><b>ScopeName</b> ':' <b>Identifier</b></td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>| <b>ScopeName</b> ':' <b>StringLiteral</b></td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>| ':' (<b>Identifier</b> | <b>StringLiteral</b>)</td>
</tr>

<tr>
<td><b>ScopeName</b></td>
<td>::=</td>
<td>'page'</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>| 'request'</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>| 'session'</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>| 'app'</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>| 'header'</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>| 'param'</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>| 'paramvalues'</td>
</tr>

<tr>
<td><b>Identifier</b></td>
<td>::=</td>
<td><i>Java language identifier</i></td>
</tr>

<tr>
<td><b>Literal</b></td>
<td>::=</td>
<td><b>BooleanLiteral</b></td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>| <b>IntegerLiteral</b></td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>| <b>FloatingPointLiteral</b></td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>| <b>StringLiteral</b></td>
</tr>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>| <b>NullLiteral</b></td>
</tr>

<tr>
<td><b>BooleanLiteral</b></td>
<td>::=</td>
<td>'true'</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>| 'false'</td>
</tr>

<tr valign="top">
<td><b>StringLiteral</b></td>
<td>::=</td>
<td>'([^'\]|\'|\\)*'</td>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>| "([^'\]|\'|\\)*"</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>i.e., a string of any characters enclosed by single or double
quotes, where \ is used to escape ', ", and \.</td>
</tr>

<tr>
<td><b>IntegerLiteral</b></td>
<td>::=</td>
<td>["+","-"] ["1"-"9"] (["0"-"9"])*</td>
</tr>

<tr>
<td><b>FloatingPointLiteral</b></td>
<td>::=</td>
<td> (["+","-"])? (["0"-"9"])+ "." (["0"-"9"])* (["e","E"] (["+","-"])? (["0"-"9"])+)?</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>| (["+","-"])? "." (["0"-"9"])+ (["e","E"] (["+","-"])? (["0"-"9"])+)?</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>| (["+","-"])? (["0"-"9"])+ ["e","E"] (["+","-"])? (["0"-"9"])+</td>
</tr>

<tr>
<td><b>NullLiteral</b></td>
<td>::=</td>
<td>'null'</td>
</tr>

</table>

<p>Notes:

<ul>

<li>An identifier is constrained to be a Java identifier - i.e., no
"-", no "/", etc. without quoting.  Eventually this may be expanded,
but this is the minimum.

<li>A String only recognizes a limited set of escape sequences, and \
may not appear unescaped.  This may eventually be expanded, but once
again, this is the minimum.

<li>The definitions for integer and floating point literal are pretty
much taken from the Java definitions.

<li>The relational operator for equality is "==" (double equals).
This is to be more Java-like, but is it the best idea?

<li>There are no logical operators (and, or, not).  Designing these
introduces the notion of grouping (parentheses) and order of
precedence, and also deciding what the actual operators should be (and
vs. &amp;&amp;), which also introduces the notion of reserved words.
It is possible that keeping these out severely limits the usefulness
of the language.  Should they be introduced?

</ul>

<h2>Reservered Words</h2>

<p>The following words are reserved for the language and should not be
used as identifiers without being quoted.

<ul><table>
<tr valign="top">

<td><pre>
and
or
not
</pre></td>

<td>&nbsp;</td>

<td><pre>
eq
ne
lt
</pre></td>

<td>&nbsp;</td>

<td><pre>
gt
le
ge
</pre></td>

<td>&nbsp;</td>

<td><pre>
true
false
null
</pre></td>

<td>&nbsp;</td>

<td><pre>
instanceof
</pre></td>

</tr>
</table></ul>

<p>Note that these words may not be in the language now, but they may
be in the future, so developers should avoid using these words now.

<h2>Named Values</h2>

<p>If a named value is specified with a scope of "page", "request",
"session", or "app", its value is the value of that name in the given
scope.  If no scope is given, the value is found according to the
rules of PageContext.findAttribute(name).

<p>If a named value is specified with a scope of "header", its value
is obtained by calling HttpServletRequest.getHeader(String).

<p>If a named value is specified with a scope of "param", its value is
obtained by calling ServletRequest.getParameter(String).

<p>If a named value is specified with a scope of "paramvalues", its
value is obtained by calling
ServletRequest.getParameterValues(String).

<p>In any of these cases, if a value is not found, the result is an <a
href="#expressionExceptions">ExpressionException</a>, not "null".

<h2>Property Values</h2>

<p>The expression "value . propertyName" denotes a property
expression.  The property is found through introspection by treating
the value as a JavaBean and calling the appropriate setter method.  If
the result is a primitive value, the result is converted to the Object
equivalent of the primitive.

<ul>

<li>It is an error if the bean value is null.

<li>It is an error if the specified property is not found in the bean.

<li>It is an error if calling the getter results in an error.

</ul>

<p>Note that these error conditions might be relaxed in the future,
but for now they are as strict as possible.

<p>In the future, the "." operator might be extended to interpret
other name/value collections, such as Maps, but for now this is not
the case.  Note that in the future, the "Map behavior" might happen
automatically, so JavaBeans should avoid implementing "java.util.Map"
to avoid having their behavior change in the future.

<h2>Type Conversion</h2>

<p>Every expression is evaluated in the context of an "expected type".
The result of the expression evaluation may not match the expected
type exactly, so the following rules are applied:

<ul>

<li>If the expected type is assignable from the value's type, no
conversion is required.

<li>If the expected type is an Object type and the value is null, no
conversion is required.

<li>If the expected type is a primitive and the value is null, an
error results.

<li>If the expected type is a primitive and the value is the Object
equivalent of that primitive, the Object equivalent is returned.

<li>If the expected type (or its Object equivalent) is a numeric type,
and the value is also a numeric type, the value is converted to the
expected type, even if loss of precision would occur.  The numeric
types are: byte, short, int, long, float, double.

<li>Any other condition is an error

</ul>

<h2>Relational Comparisons</h2>

<p>The following rules are applied to evaluate a relational
comparison.

<h3>Rules for == and !=</h3>

<p>The rules for equality are as follows:

<ul>

<li>If both values are null, the values are considered to be equal

<li>If only one value is null, the values are not equal

<li>If both values are the same object, the values are considered to
be equal

<li>If both values are numeric types, then the value with the least
precise type is "cast up" to the type of the other value, and their
values are compared.  The order of numeric types from least precise to
most precise is byte, short, int, long, float, double

<li>If leftHandValue.equals(rightHandValue), the values are considered
to be equal

<li>In all other cases, the values are not equal

</ul>

<h3>Rules for &gt;, &lt;, &gt;=, &lt;=</h3>

<p>The rules for ordered comparisons are as follows:

<ul>

<li>If both values are Strings, the Strings are comapared according to
the rules of String.compareTo(String).

<li>If both values are numeric types, then the value with the least
precise type is "cast up" to the type of the other value, and their
values are compared.  The order of numeric types from least precise to
most precise is byte, short, int, long, float, double

<li>All other cases result in an error

</ul>

<a name="expressionExceptions"><h2>ExpressionExceptions</h2></a>

<p>The ExpressionException mechanism in the JSTL is provided as a way
for expression languages to indicate that there was a problem
evaluating an expression, but the problem was small enough that a
default value could be substituted in its place without invoking the
entire JSP error handling mechanism.

<p>The SPEL throws javax.servlet.jsp.jstl.core.ExpressionException in the
following situations:

<ul>

<li>A NamedValue (e.g., "session:profile") can't be found.  If the
specified name is not found in the specified scope, then an
ExpressionException is thrown, not a null value.

<li>A requested property of a bean can't be evaluated, either because:

<ul>

<li>the bean's value is null

<li>the bean does not have the specified property

<li>the bean's property is not readable

<li>there is an error invoking the bean's read method

</ul>

</ul>

<h2>Literals and Delimiter</h2>

<p>The SPEL is responsible for handling both expressions and
literals.  Expressions begin with a "$" character.  For example:

<ul><pre>
&lt;mytags:if test="$bean1.a &lt; 3" /&gt;
</pre></ul>

<p>Any value that does not begin with "$" is treated as a literal that
is parsed to the expected type using the PropertyEditor for the
expected type:

<ul><pre>
&lt;mytags:if test="true" /&gt;
</pre></ul>

<p>There may be literal values that start with the "$" character.  If
that is the case, the value must be escaped using the "\" character.:

<ul><pre>
&lt;mytags:price price="\$3.95" /&gt;
</pre></ul>

<p>If a value starts with "\$", it is treated as a literal value with
the leading "\" removed.

<h4><i>$Change: 181991 $$DateTime: 2001/07/02 16:12:52 $$Author$</i></h4>

</html>

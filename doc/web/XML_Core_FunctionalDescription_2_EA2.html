<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.76 [en] (Windows NT 5.0; U) [Netscape]">
   <title>XML Core -- Functional Description</title>
<style media="screen" type="text/css"><!--
.fixme { color: red }
--></style>
</head>
<body bgcolor="#FFFFFF">
<h3> 
  <hr width="100%" noshade>
</h3>
<h2> XML Core Tags &#151; Functional Description <br>
</h2>
<h2> <tt>&lt;x:parse><br>
  &lt;x:expr&gt;<br>
  &lt;x:set&gt;</tt><tt><br>
  </tt></h2>
<hr width="100%" noshade>
<h3>1. Introduction</h3>
<p>Enterprise data used in the web tier is increasingly XML these days &#151; 
  whether the enterprise data is a response coming from a Web Service, the result 
  of a stock quote from Nasdaq, a google search, babel fish translation, an Amazon 
  book search, NewsML news articles, or RSS for content syndication. When companies 
  cooperate over the web, XML is the data format of choice for exchanging information.<br>
</p>
<p>XML is therefore becoming more and more important in a page author's life. 
  The set of XML tags specified in JSTL is therefore meant to address the basic 
  XML needs a page author is likely to encounter.</p>
<h4>XPath</h4>
<p>A key aspect of dealing with XML documents is to be able to easily access their 
  content. <a href="http://www.w3.org/TR/xpath">XPath</a>, a W3C recommendation 
  since 1999, provides an easy notation for specifying and selecting parts of 
  an XML document. The XML tagset in JSTL is therefore based on XPath.</p>
<p>For the <i>XPath challenged</i>, here are a few links to get you started quickly:</p>
<ul>
  <li><a href="http://www.zvon.org/xxl/XPathTutorial/General/examples.html">Zvon 
    XPath Tutorial</a></li>
  <li><a href="http://www.oreilly.com/catalog/xmlnut/chapter/ch09.html">XML in 
    a Nutshell &#151; Chapter 9 &#151; XPath</a></li>
</ul>
<p>It is important to note that the Expert Group is still debating which <i>global</i> 
  Expression Language(s) will be officially supported by JSTL. While this discussion 
  is still taking place, the approach we've taken here is to consider XPath as 
  a <i>local</i> Expression Language that applies to the XML tagset. How this 
  local XPath Expression Language integrates with the Global Expression Language 
  as well as JSP.next is briefly discussed in this document. </p>
<p>The assumption is that if XPath (or a derivative) is not selected as <i>the</i> 
  or one of <i>the</i> Global Expression Languages, this set of tags would probably 
  stay as is. If XPath were to become one of <i>the</i> Global ELs, the design 
  of these tags would probably change, the extent of which has not yet been addressed.<br>
</p>
<h3>2. XPath as a <i>local</i> Expression Language for the XML set of tags</h3>
<p>What we're doing with our set of XML tags is expanding our notion of Expression 
  Language so it can also apply &quot;locally&quot; to tags that want to support 
  an EL that is not <i>the</i> global one(s) supported within JSTL.</p>
<p>Below are the rules of integration that XPath follows as a <i>local</i> EL, 
  so we have the guarantees that it plays nicely within the JSP/JSTL environment.</p>
<h4>XPath Context</h4>
  In XPath, the context for evaluating an expression consists of:: 
<ul>
  <li> a node or nodeset (see below)</li>
  <li>variable bindings (see below)</li>
  <li>function library: the default function library comes with the XPath engine. 
    Some engines provide extension functions or allow customization to add new 
    functions. The XPath function library in JSTL is limited to the core function 
    library of the XPath specification.</li>
  <li>namespace prefix definitions which allow namespace prefixes to be used within 
    the XPath expression<br>
    ( e.g. /SOAP-ENV:Envelope/SOAP-ENV:Body/m:foo)</li>
</ul>
<p><b>Attributes to specify XPath Expressions</b></p>
<p>In the JSTL set of XML tags, XPath expressions are always specified using 
  attribute &quot;select&quot;. This therefore means that only values specified 
  for &quot;select&quot; attributes are evaluated using the XPath expression language. 
  All other attributes are evaluated using the rules associated with the currently 
  active global Expression Language. This should help avoid confusion between 
  XPath and the global Expression Language.</p>
<p><b>XPath Variable Bindings</b></p>
<p>JSTL supports variables in XPath expressions. The mapping of XPath variable 
  expressions is defined as follows:<p>
<table border="1" cellpadding="2" cellspacing="1">
  <tr> 
    <td><code>$foo</code></td>
    <td>maps to <code>pageContext.findAttribute(&quot;foo&quot;)</code></td>
  </tr>
  <tr> 
    <td><code>$page:foo</code></td>
    <td>maps to page scope</td>
  </tr>
  <tr> 
    <td><code>$request:foo</code></td>
    <td>maps to request scope</td>
  </tr>
  <tr> 
    <td><code>$session:foo</code></td>
    <td>maps to session scope</td>
  </tr>
  <tr> 
    <td><code>$app:foo</code></td>
    <td>maps to application scope</td>
  </tr>
  <tr> 
    <td><code>$param:foo</code></td>
    <td>maps to <code>request.getParameter(&quot;foo&quot;)</code></td>
  </tr>
  <tr> 
    <td><code>$initParam:foo</code></td>
    <td>maps to <code>request.getInitParameter(&quot;foo&quot;)</code></td>
  </tr>
  <tr> 
    <td><code>$cookie:foo</code></td>
    <td>maps to the cookie's value for name <code>foo</code></td>
  </tr>
  <tr> 
    <td><code>$header:foo</code></td>
    <td>maps to <code>request.getHeader(&quot;foo&quot;)</code></td>
  </tr>
</table>
<p>Through these mappings, scoped attributes, parameters, headers, and cookies 
  can all be used inside XPath expressions easily. For example: 
<blockquote>
  <p> <code>/foo/bar[@x=$param:name]</code></p>
</blockquote>
<p> would find the &quot;bar&quot; element with an attribute &quot;x&quot; equal 
  to the value of the http request parameter &quot;name&quot;.<br>
</p>
<p><b>Context Setup</b></p>
<p>The context for the evaluation of an XPath Expression can be set in one of 
  two ways; either directly within the XPath expression:</p>
<blockquote> 
  <p><code>&lt;x:parse source=&quot;$xml&quot; var=&quot;doc&quot;/&gt;<br>
    &lt;x:expr select=&quot;$doc/...&quot;/&gt;</code></p>
</blockquote>
<p>or via an ancestor tag that sets a context that can be applied to its nested 
  tags. In the example below, the XPath expression specified in the select attribute 
  of &lt;expr&gt; has its context set to the current &quot;atom&quot; node in 
  the document.</p>
<blockquote> 
  <p><code>&lt;x:forEach select=&quot;$doc//atom&quot;/&gt;<br>
    &nbsp;&nbsp;&lt;x:expr select=&quot;name&quot;/&gt;<br>
    &lt;x:forEach/&gt; </code></p>
</blockquote>
<h4>Relationship between Local EL and the Global EL(s)</h4>
<p>As mentioned in the previous section, only the &quot;select&quot; attribute 
  of xml tags can take XPath expressions. Global EL expressions and XPath expressions 
  cannot be mixed in the &quot;select&quot; attributes. </p>
<p>With JSTL 1.0, the xml tagset knows that the value of select attributes are 
  XPath expressions. However, things will be different in JSP.next when the evaluation 
  of 'elexprvalues' are handled directly by the container. If the metacharacter 
  used to identify an 'elexprvalue' is defined as '$', this means that XPath expressions 
  starting with a variable would have to be escaped in a JSP.next environment, 
  unless JSP.next has provisions in the TLD to prevent expression evaluation.</p>
<p>There might be other issues. These will be addressed once the discussions on 
  the Expression Language resume.</p>
<h3>3. &lt;parse&gt;</h3>
<p>The &lt;parse&gt; action parses an XML document and saves the resulting object 
  in the JSP scoped attribute specified by attribute &quot;var&quot;. The type 
  of the resulting object is not defined by the spec to allow implementations 
  to use whatever they deem best for efficient implementations of the XML tagset.</p>
<p>The XML document can be specified either via the &quot;source&quot; attribute 
  (String or Reader object) </p>
<blockquote>
  <pre>&lt;jc:import url=&quot;http://acme.com/athletes?country=ethiopia&quot; var=&quot;xml&quot;/><br>&lt;x:parse source=&quot;$xml&quot; var=&quot;athletes&quot;/&gt;</pre>
</blockquote>
<p>or inline via the tag's body content:</p>
<blockquote>
  <pre>&lt;x:parse var=&quot;athletes&quot;&gt;
  &lt;athletes&gt;
    &lt;athlete&gt;
      &lt;name&gt;Abebe Bikila&lt;/name&gt;
      &lt;country&gt;Ethiopa&lt;/country&gt;<br>    &lt;/athlete&gt;  
    &lt;athlete&gt;
      &lt;name&gt;Mamo Wolde&lt;/name&gt;
      &lt;country&gt;Ethiopia&lt;/country&gt;<br>    &lt;/athlete&gt;
  &lt;/athletes&gt;
&lt;/x:parse&gt;
</pre>
</blockquote>
<p> When used in conjunction with the &lt;parse&gt; tag, the JSTL core tag &lt;import&gt; 
  provides access to a wide variety of URL-based input resources representing 
  XML documents.</p>
<h4>Performance</h4>
<p> If an implementation of the XML tagset is based on DOM-like structures (check 
  with the specific implementation you're using), there will be a significant 
  performance impact when dealing with large XML documents. To help with this, 
  attribute &quot;filter&quot; can be used to allow filtering of the input data 
  prior to having it parsed by the implementation into a DOM-like structure. </p>
<p>For example, if one is interested in processing only the &quot;European&quot; 
  customers which represent only 10% of the original XML document received as 
  input, it will greatly reduce the size and complexity of the resulting DOM structure 
  if all non-European customers are pruned from the XML document prior to parsing. 
</p>
<pre>  &lt;jc:import url=&quot;http://acme.com/customers&quot; var=&quot;xml&quot;/><br>  &lt;x:parse source=&quot;$xml&quot; filter=&quot;$filterEuropeanCust&quot; var=&quot;doc&quot;/&gt;</pre>
<p>The &quot;filter&quot; attribute accepts an object of type <code>org.xml.sax.XMLFilter</code>.</p>
<p>If configuration of the filter is desirable, it is suggested that the developer 
  of the filter provide a custom tag for easy configuration by a page author.</p>
<blockquote>
  <p> <code>&lt;acme:myFilter var=&quot;filter&quot; xpath=&quot;//author&quot; 
    ... /&gt;<br>
    &lt;x:parse filter=&quot;$filter&quot; .../&gt;</code></p>
</blockquote>
<h3>4. &lt;expr&gt;</h3>
<p>The <tt>&lt;expr></tt> action evaluates the given XPath expression on the current 
  context node and outputs the result of the evaluation to the current JspWriter 
  object. It is the equivalent of <tt>&lt;%= %></tt> and <code>&lt;jc:expr&gt;</code>, 
  with the difference that it is meant for the XPath Expression Language world 
  (as opposed to the scripting language world (<code>&lt;%= %&gt;</code>) and 
  the Global Expression Language world of JSTL <code>&lt;jc:expr&gt;</code>). 
</p>
<p>The expression to be evaluated is specified via the attribute &quot;select&quot; 
  and must be in the XPath syntax. The result of the evaluation is coerced to 
  a String and is subsequently emitted into the current JspWriter object. </p>
<p>For example: </p>
<p><tt>&nbsp; &lt;x:expr select="$athletes/athlete/name&quot;/&gt;</tt> </p>
<h3>5. &lt;set&gt;</h3>
<p>The <tt>&lt;set></tt> action evaluates an XPath expression (attribute &quot;select&quot;) 
  and sets the result into a JSP scoped attribute specified by attribute &quot;var&quot;. 
</p>
<p>In this first example, the list of athletes from a specific country is saved 
  in scoped attribute athletesOfCountry:</p>
<blockquote> <code>&lt;x:set select=&quot;$athletes/athlete[country=$request:country]&quot; 
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var=&quot;athletesOfCountry&quot;/&gt; 
  </code></blockquote>
<p>In this second example, the &lt;set&gt; action is used to set a context used 
  by other xml tags:</p>
<blockquote>
  <pre>&lt;x:set select=&quot;$athletes/athlete[id=$param:athleteId]&quot; var=&quot;ath&quot;/&gt;

&lt;x:expr select=&quot;$ath/name&quot;/&gt;<br>&lt;x:expr select=&quot;$ath/country&quot;/&gt;</pre>
</blockquote>
<h3>6. Notes</h3>
<ul>
  <li> 
    <p>Some XPath expressions can be evaluated without a context<br>
      For example:<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>starts-with($header:user-agent, 
      'Mozilla 4.0')</code></p>
  </li>
</ul>
<h3>7. Summary</h3>
<table border="1" cellpadding="5">
  <tr> 
    <td colspan="2" bgcolor="#000099"><b><font color="#FFFFFF" size="+1">XML Core 
      Tags</font></b></td>
  </tr>
  <tr bgcolor="#FFFF66"> 
    <td width="318"><b>Element</b></td>
    <td width="392"><b>Sample usage</b></td>
  </tr>
  <tr> 
    <td width="318"><code><b>&lt;parse&gt;</b></code><br>
      <code><font color="#FF0000"><b><font color="#000000">var</font></b></font> 
      source filter</code><br>
      <br>
      Parses an XML and saves its internal representation into the JSP scoped 
      attribute specified by &quot;var&quot;.</td>
    <td width="392"> <code>&lt;c:import url=&quot;http://acme.com/athletes?country=ethiopia&quot; 
      var=&quot;xml&quot;/><br>
      &lt;x:parse source=&quot;$xml&quot; var=&quot;athletes&quot;/&gt; </code></td>
  </tr>
  <tr> 
    <td width="318"> 
      <p><code><b>&lt;expr&gt;</b></code><br>
        <code><font color="#000000"><b>select</b></font></code><br>
        <br>
        Evaluates the given XPath expression and outputs its text value.<br>
      </p>
    </td>
    <td width="392"> 
      <p><code>&lt;x:expr select=&quot;$ath/name&quot;/&gt;</code></p>
    </td>
  </tr>
  <tr> 
    <td width="318"> 
      <p><code><b>&lt;set&gt;</b></code><br>
        <code><font color="#000000"><b>var</b></font> <b><font color="#000000">select</font></b></code><br>
        <br>
        Evaluates the given XPath expression and saves the result into the JSP 
        scoped attribute specified by &quot;var&quot;.</p>
    </td>
    <td width="392"> <code>&lt;x:set<br>
      &nbsp;&nbsp;select=&quot;$athletes/athlete[country=$request:country]&quot; 
      &nbsp;&nbsp;var=&quot;athletesOfCountry&quot;/&gt;</code></td>
  </tr>
</table>
</body>
</html>

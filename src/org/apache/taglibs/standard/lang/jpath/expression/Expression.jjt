options {
   MULTI=true;
   STATIC=false;
   NODE_PREFIX="";
   NODE_SCOPE_HOOK=true;
}

PARSER_BEGIN(Parser)
package org.apache.taglibs.standard.lang.jpath.expression;

import java.io.StringReader;

public class Parser {
    public static Expression parse(String expressionText) 
            throws ParseException {
        Parser parser;
        Expression expression;
        parser = new Parser(new StringReader(expressionText));
        parser.Expression();
        expression  = (Expression)parser.jjtree.rootNode();
        return expression;
    }

    void jjtreeOpenNodeScope(Node n) {
        ((SimpleNode)n).firstToken = getToken(0);
    }

    void jjtreeCloseNodeScope(Node n) {
        ((SimpleNode)n).lastToken = getToken(0);
    }
    
}

PARSER_END(Parser)


/*----------------------------*/
/* Skip Whitespace everywhere */
/*----------------------------*/
SKIP :
{
  " "
| 
  "\t"
| 
  "\r"
| 
  "\n"
| 
  "\f"
}


/*-----------------*/
/* Operator Tokens */
/*-----------------*/


TOKEN:
{
  <DIV:"/">
| 
  <MULT:"*">
| 
  <MOD:"%">
| 
  <PLUS:"+">
| 
  <MINUS:"-">
| 
  <EQ:"=">
| 
  <NEQ:"!=">
| 
  <LT:"<">
| 
  <LTE:"<=">
|
  <GT:">">
| 
  <GTE:">=">
| 
  <INTROSPECT:".">
| 
  <UNION:"|">
| 
  <SCOPE_LIMIT:":">
| 
  <AND:"and">
| 
  <OR:"or">
| 
  <LIST_BEGIN:"{">
| 
  <LIST_END:"}">
| 
  <SEPARATOR:",">
|
  <FUNCTION_BEGIN:"(">
| 
  <FUNCTION_END:")">
|
  <PREDICATE_BEGIN:"[">
| 
  <PREDICATE_END:"]">
}

/*
 * Expression syntax follows.
 */

void Expression() #Expression(1):
{}
{
  Expr() <EOF>
}

/* [1] Expr ::= OrExpr */
void Expr() #void:
{}
{
  OrExpr()
}


/* [2] OrExpr ::= AndExpr ( 'or' AndExpr )* */
void OrExpr() #void :
{}
{
  AndExpr()
  ( <OR> AndExpr() #OrOperator(2) )*
}

/* [3] AndExpr ::= EqualityExpr ( 'and' EqualityExpr )* */
void AndExpr() #void :
{}
{
  EqualityExpr()
  ( <AND> EqualityExpr() #AndOperator(2) )*
}

/* [4] EqualityExpr ::= RelationalExpr ( ( '=' | '!-' ) RelationExpr )* */
void EqualityExpr() #void :
{}
{
  RelationalExpr()
  (
     <EQ> RelationalExpr() #EqualsOperator(2)
   |
     <NEQ> RelationalExpr() #NotEqualsOperator(2)
  )*
}

/* [5] RelationalExpr ::= AdditiveExpr ( ( '<' | '>' | '<=' | '>=' ) AdditiveExpr )* */
void RelationalExpr() #void :
{}
{
  AdditiveExpr()
  (
    <LT> AdditiveExpr() #LessThanOperator(2)
   |
    <GT> AdditiveExpr() #GreaterThanOperator(2)
   |
    <LTE> AdditiveExpr() #LessThanEqualOperator(2)
   |
    <GTE> AdditiveExpr() #GreaterThanEqualOperator(2)
  )*
}

/* [6] AdditiveExpr ::= MultiplicitiveExpr ( ( '+' | '-' ) MultiplicitiveExpr )* */
void AdditiveExpr() #void :
{}
{
  MultiplicativeExpr()
  (
    <PLUS> MultiplicativeExpr() #AdditionOperator(2)
   |
    <MINUS> MultiplicativeExpr() #SubtractionOperator(2)
  )*
}

/* [7] MultiplicitiveExpr ::= UnaryExpr ( ( '*' | '/' | '%' ) UnaryExpr )* */
void MultiplicativeExpr() #void :
{}
{
  UnaryExpr()
  (
    <MULT> UnaryExpr() #MultiplicationOperator(2)
   |
    <DIV> UnaryExpr() #DivisionOperator(2)
   |
    <MOD> UnaryExpr() #ModulusOperator(2)
  )*
}

/* [7] UnaryExpr ::= UnionExpr | '-' UnaryExpr */
void UnaryExpr() #void :
{}
{
  UnionExpr()
  | <MINUS> UnaryExpr()
}

/* [7] UnionExpr ::= IntrospectiveExpr ( '|' IntrospectiveExpr )* */
void UnionExpr() #void :
{} 
{
  IntrospectiveExpr() ( <UNION> IntrospectiveExpr() #UnionOperator(2) )*
}

/* [7] IntrospectiveExpr ::= PathExpr ( '.' PathExpr )* */
void IntrospectiveExpr() #void :
{}
{
  PathExpr()
  (
    <INTROSPECT> PathExpr() #IntrospectionOperator(2)
  )*
}

/* [7] PathExpr ::= FilterExpr */
void PathExpr() #void :
{}
{
   FilterExpr()
}

/* [7] FilterExpr ::= PrimaryExpr ( Predicate )* */
void FilterExpr() #void :
{}
{
PrimaryExpr() ( Predicate() #FilterOperator(2) )*
}


/* [] Predicate ::= '[' PredicateExpr ']' */
void Predicate() #Predicate(1) :
{}
{
  <PREDICATE_BEGIN> PredicateExpr() <PREDICATE_END>
}

/* [] PredicateExpr ::= Expr */
void PredicateExpr() #void :
{}
{
  Expr()
}


/* [7] PrimaryExpr ::= Literal | '(' Expr ')' | FunctionCall | ScopeLimitExpr | Identifier */
void PrimaryExpr() #void :
{}
{
  Literal()
|
  "(" Expr() ")"
|
  LOOKAHEAD(2) Function()
|
  ScopeLimitExpr()
|
  LOOKAHEAD(2) Identifier()
}

/* FunctionCall ::= FunctionName '(' ( Argument ( ',' Argument)*)? ')'  */
/* FunctionName ::= 'boolean' | 'number' | 'string' | 'not' | ...  */
void Function() #void :
{
}
{
   "boolean(" Argument() <FUNCTION_END> #BooleanFunction(1)
  |
   "number(" Argument() <FUNCTION_END> #NumberFunction(1)
  |
   "string(" Argument() <FUNCTION_END> #StringFunction(1)
  |
   "not(" Argument() <FUNCTION_END> #NotFunction(1)
  |
   "floor(" Argument() <FUNCTION_END> #FloorFunction(1)
  |
   "ceiling(" Argument() <FUNCTION_END> #CeilingFunction(1)
  |
   "round(" Argument() <FUNCTION_END> #RoundFunction(1)
  |
   ( "format-number(" Argument() <SEPARATOR> Argument() ( <SEPARATOR> Argument() )? <FUNCTION_END> ) #FormatNumberFunction(>1)
  |
   ( "concat(" Argument() (<SEPARATOR> Argument())+ <FUNCTION_END> ) #ConcatFunction(>1)
  |
   "encode-url(" Argument() <FUNCTION_END> #EncodeUrlFunction(1)
  |
   "encode-html(" Argument() <FUNCTION_END> #EncodeHtmlFunction(1)
  |
   "string-length(" Argument() <FUNCTION_END> #StringLengthFunction(1)
  |
   ( "substring(" Argument() <SEPARATOR> Argument() (<SEPARATOR> Argument() )? <FUNCTION_END> ) #SubstringFunction(>1)
  |
   ( "starts-with(" Argument() <SEPARATOR> Argument() <FUNCTION_END> ) #StartsWithFunction(2)
  |
   ( "contains(" Argument() <SEPARATOR> Argument() <FUNCTION_END> ) #ContainsFunction(2)
  |
   ( "substring-before(" Argument() <SEPARATOR> Argument() <FUNCTION_END> ) #SubstringBeforeFunction(2)
  |
   ( "substring-after(" Argument() <SEPARATOR> Argument() <FUNCTION_END> ) #SubstringAfterFunction(2)
  |
   ( "translate(" Argument() <SEPARATOR> Argument() <SEPARATOR> Argument() <FUNCTION_END> ) #TranslateFunction(3)
  |
   "position(" <FUNCTION_END> #PositionFunction(0)
  |
   "current(" <FUNCTION_END> #CurrentFunction(0)
  |
   "last(" <FUNCTION_END> #LastFunction(0)
  |
   "count(" Argument() <FUNCTION_END> #CountFunction(1)
  |
   "sum(" Argument() <FUNCTION_END> #SumFunction(1)
  |
   "now(" <FUNCTION_END> #NowFunction(0)
  |
   ( "date(" Argument() (<SEPARATOR> Argument())+ <FUNCTION_END> ) #DateFunction(>1)
  |
   ( "format-date(" Argument() <SEPARATOR> Argument() ( <SEPARATOR> Argument() )? <FUNCTION_END> ) #FormatDateFunction(>1)
  |
   ( "roll-date(" Argument() <SEPARATOR> Argument() <SEPARATOR> Argument() <FUNCTION_END> ) #RollDateFunction(3)
  |
   ( "add-date(" Argument() <SEPARATOR> Argument() <SEPARATOR> Argument() <FUNCTION_END> ) #AddDateFunction(3)
  |
   ( "tokenize(" Argument() <SEPARATOR> Argument() <FUNCTION_END> ) #TokenizeFunction(2)
  |
   ( Identifier() ":" Identifier() <FUNCTION_BEGIN> [ Argument() (<SEPARATOR> Argument() )* ] <FUNCTION_END> ) #UserFunction(>1)
}

/* [] Argument ::= Expr */
void Argument() #void :
{
}
{
   Expr()
}

/* [] ScopeLimitExpr ::= ScopeLimitName Identifier */
void ScopeLimitExpr() #void :
{
   Token t;
}
{
  ScopeLimitName()
  (
    Identifier() #ScopeLimitOperator(2)
  )
}


/* [] Identifier ::= Letter ( Letter | Digit )* */
void Identifier() :
{
   Token t;
}
{
   t = <IDENTIFIER>  
    {
        jjtThis.val = t.image; 
        jjtThis.image = t.image; 
        jjtThis.beginColumn = t.beginColumn; 
        jjtThis.endColumn = t.endColumn; 
        jjtThis.beginLine = t.beginLine; 
        jjtThis.endLine = t.endLine; 
    }
}

/* ScopeLimitName ::= 'page' | 'request' | 'session' | 'application' | ...  */
void ScopeLimitName() :
{
   Token t;
}
{
  t = < SCOPE_LIMIT_NAME: ("page:" | "request:" | "session:" | "application:") > { jjtThis.val = t.image; }
}

/* Literal ::= UnaryLiteral | ListLiteral */
void Literal() #void :
{}
{
   UnaryLiteral()
  |
   ListLiteral()
}

/* UnaryLiteral ::= BooleanLiteral | NumberLiteral | StringLiteral */
void UnaryLiteral() #void :
{
   Token t;
}
{
 (
  t=<BOOLEAN_LITERAL>
    {
       jjtThis.val = Boolean.valueOf(t.image).booleanValue();
    }
 )#BooleanLiteral
| 
 (
  t=<NUMBER_LITERAL>
    {
       jjtThis.val = Double.parseDouble(t.image);
    }
 )#NumberLiteral
|
 (
  t=<STRING_LITERAL>
    {
       jjtThis.val = t.image.substring(1, (t.image.length() - 1));
    }
 )#StringLiteral
}

/* ListLiteral ::= '{' UnaryExpr ( ',' UnaryExpr )* '}' */
void ListLiteral() :
{}
{
    <LIST_BEGIN> Expr() ( <SEPARATOR> Expr() )* <LIST_END>#ListLiteral(>1)
}


/*-----------------------------------------------*/
/* Unambigious Tokens (Number, Literal)          */
/*-----------------------------------------------*/

TOKEN:
{

/* [] BooleanLiteral ::= "true" | "false"  */
  <BOOLEAN_LITERAL :
    "true"
  |
    "false"
  >

|
 
/* [] StringLiteral ::= '"' [^"]* '"' | "'" [^']* "'"  */
  <STRING_LITERAL :
    "\"" (~["\""])* "\""
  |
    "'"  (~["'"] )* "'"
  >

|

/* [] Digit ::= [0-9]+  */
  <#DIGIT :
    ["0"-"9"]
  >

|

/* [] NumberLiteral ::= Digits ( '.' Digits? )?  | '.' Digits  */
  <NUMBER_LITERAL :
    ("-")? (<DIGIT>)+ ("." ( (<DIGIT>)+ )? )?
|
    ("-")? "." (<DIGIT>)+
  >

|
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
|
/* [] Letter ::= ['a'-'z'], ['A'-'Z'] */
  < #LETTER: [ "a"-"z", "A"-"Z" ] >
}

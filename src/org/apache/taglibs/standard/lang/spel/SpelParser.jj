options {
  JAVA_UNICODE_ESCAPE = true;
  STATIC = false;
}

PARSER_BEGIN(SpelParser)

package org.apache.taglibs.standard.lang.spel.parser;

import org.apache.taglibs.standard.lang.spel.*;
import java.util.ArrayList;
import java.util.List;

public class SpelParser {

  public static void main(String args[]) 
       throws ParseException
  {
    SpelParser parser = new SpelParser (System.in);
    parser.Expression ();
  }

}

PARSER_END(SpelParser)


/* WHITE SPACE */

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}


/* LITERALS */

TOKEN :
{
  < INTEGER_LITERAL: (<SIGN>)? ["0"-"9"] (["0"-"9"])* >
|
  < FLOATING_POINT_LITERAL:
        (<SIGN>)? (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)?
      | (<SIGN>)? "." (["0"-"9"])+ (<EXPONENT>)?
      | (<SIGN>)? (["0"-"9"])+ <EXPONENT>
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < #SIGN: ["+","-"] >
|
  < STRING_LITERAL:
      ("\"" ((~["\"","\\"]) | ("\\" ( ["\\","\""] )))* "\"") |
      ("\'" ((~["\'","\\"]) | ("\\" ( ["\\","\'"] )))* "\'")
  >
}

/* RESERVED WORDS */

TOKEN :
{
< TRUE: "true" >
| < FALSE: "false" >
| < NULL: "null" >
| < PAGE: "page" >
| < REQUEST: "request" >
| < SESSION: "session" >
| < APP: "app" >
| < HEADER: "header" >
| < PARAM: "param" >
| < PARAMVALUES: "paramvalues" >

| < AND: "and" >
| < OR: "or" >
| < NOT: "not" >
| < EQ_VALUE: "eq" >
| < NE_VALUE: "ne" >
| < LT_VALUE: "lt" >
| < GT_VALUE: "gt" >
| < LE_VALUE: "le" >
| < GE_VALUE: "ge" >
| < INSTANCEOF: "instanceof" >
}

/* IDENTIFIERS */

TOKEN :
{
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
|
  < #LETTER:
      [
       "\u0024",
       "\u0041"-"\u005a",
       "\u005f",
       "\u0061"-"\u007a",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
      ]
  >
|
  < #DIGIT:
      [
       "\u0030"-"\u0039",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ]
  >
}

/* SEPARATORS */

TOKEN :
{
  < COLON: ":" >
| < DOT: "." >
| < GT: ">" >
| < LT: "<" >
| < EQ: "==" >
| < LE: "<=" >
| < GE: ">=" >
| < NE: "!=" >
| < START_BRACKET: "[" >
| < END_BRACKET: "]" >
}


/*****************************************
 * THE SPEL GRAMMAR STARTS HERE *
 *****************************************/

Expression Expression () :
{
  Expression ret;
}
{
  (
   LOOKAHEAD (RelationalExpression ()) (ret = RelationalExpression () <EOF>)
   | LOOKAHEAD (4) (ret = Value () <EOF>)
   )
    { return ret; }
}


Expression RelationalExpression () :
{
  Expression val1;
  Expression val2;
  RelationalOperator op;
}
{
  (
   val1 = Value ()
   op = RelOp ()
   val2 = Value ()
   )
    { return new RelationalExpression (val1, val2, op); }
}


RelationalOperator RelOp () :
{
}
{
  <EQ> { return RelationalOperator.EQ; }
  | <NE> { return RelationalOperator.NE; }
  | <LT> { return RelationalOperator.LT; }
  | <GT> { return RelationalOperator.GT; }
  | <LE> { return RelationalOperator.LE; }
  | <GE> { return RelationalOperator.GE; }
}


Expression Value () :
{
  Expression ret;
}
{
  (
   ret = PropertyValue ()
   | ret = Literal ()
   )
    { return ret; }
}


Expression PropertyValue () :
{
  Expression base;
  ArrayList l = null;
  StringLiteral pname;
  ArrayList baseIndexes = null;    // index values for the base
  ArrayList pnameIndexes = null;   // list of pname indexes (list of lists)
  IntegerLiteral index;		   // individual (working) index
}
{
  (
   base = NamedValue ()
     (
	<START_BRACKET> index = IntegerLiteral() <END_BRACKET>
        {
	  if (baseIndexes == null) baseIndexes = new ArrayList();
	  baseIndexes.add (index.getValue());
        }
     )*
   (<DOT>
    (pname = Identifier ()
     | pname = StringLiteral ()
    )
    {
     if (l == null) {
	l = new ArrayList ();
	pnameIndexes = new ArrayList();
     }
     l.add (pname.getValue ());
     pnameIndexes.add(new ArrayList());		// seed with empty list
    }
      (
	<START_BRACKET> index = IntegerLiteral() <END_BRACKET>
        {
	  // get the last index-list
	  List ind = (List) pnameIndexes.get(pnameIndexes.size() - 1);
	  ind.add(index.getValue());
        }
      )*
    )*
   )

    {
      String[] pnames;
      if (l == null) {
        // (SB: Let's collapse this distinction for simplicity;
        //   it won't matter later -- 'pnames' can sensibly be null.)
        // return base;
	pnames = null;
      } else {
	pnames = (String []) l.toArray (new String [l.size ()]);
      }
      return new PropertyExpression (base, baseIndexes, pnames, pnameIndexes);
    }
}


NamedValue NamedValue () :
{
  Scope scope = Scope.UNSCOPED;
  StringLiteral name;
}
{
  (
   LOOKAHEAD (3) (scope = ScopeName () <COLON> name = Identifier ())
   | LOOKAHEAD (3) (scope = ScopeName () <COLON> name = StringLiteral ())
   | LOOKAHEAD (3) (<COLON> name = Identifier ())
   | LOOKAHEAD (3) (<COLON> name = StringLiteral ())
   | LOOKAHEAD (3) (name = Identifier ())
   )
    { return new NamedValue (scope, (String) name.getValue ()); }
}


Scope ScopeName () :
{
}
{
  <PAGE> { return Scope.PAGE; }
  | <REQUEST> { return Scope.REQUEST; }
  | <SESSION> { return Scope.SESSION; }
  | <APP> { return Scope.APP; }
  | <HEADER> { return Scope.HEADER; }
  | <PARAM> { return Scope.PARAM; }
  | <PARAMVALUES> { return Scope.PARAMVALUES; }
}


StringLiteral Identifier () :
{
  Token t;
}
{
  (
   t = <IDENTIFIER>
   | t = <PAGE>
   | t = <REQUEST>
   | t = <SESSION>
   | t = <APP>
   | t = <HEADER>
   | t = <PARAM>
   | t = <PARAMVALUES>
   )
    { return StringLiteral.fromLiteralValue (t.image); }
}


Literal Literal () :
{
  Literal ret;
}
{
  (
   ret = BooleanLiteral ()
   | ret = IntegerLiteral ()
   | ret = FloatingPointLiteral ()
   | ret = StringLiteral ()
   | ret = NullLiteral ()
   )
    { return ret; }
}


BooleanLiteral BooleanLiteral () :
{
}
{
  <TRUE> { return BooleanLiteral.TRUE; }
  | <FALSE> { return BooleanLiteral.FALSE; }
}


StringLiteral StringLiteral () :
{
  Token t;
}
{
  t = <STRING_LITERAL>
  { return StringLiteral.fromToken (t.image); }
}


IntegerLiteral IntegerLiteral () :
{
  Token t;
}
{
  t = <INTEGER_LITERAL>
  { return new IntegerLiteral (t.image); }
}


FloatingPointLiteral FloatingPointLiteral () :
{
  Token t;
}
{
  t = <FLOATING_POINT_LITERAL>
  { return new FloatingPointLiteral (t.image); }
}


NullLiteral NullLiteral () :
{
}
{
  <NULL>
    { return NullLiteral.SINGLETON; }
}

